---
title: 面试题
date: 2022-10-16 11:23:01
tags:
---

# 计算机网络

TCP   三次握手：客户端发送SYN同步请求，服务端发送SYN+ACK，客户端发送ACK

四次挥手：客户端发送FIN+ACK，服务端发送ACK，服务端发送FIN+ACK，客户端发送ACK

不是两次握手，防止已失效的连接请求报文传到TCP服务器，出现错误



常用的状态码：1xx  表示请求还在进行中

200成功   201已创建请求    204无内容返回

3xx重定向   301永久移动了地址，更新url     302临时移动     304使用缓存内容，服务器资源没变

4xx客户端错误   400语法错误    401身份认证不成功    403权限不够    404没有这样的资源和路径，可能地址写错或者资源不在了  409版本不对

5xx服务器错误   500内部错误   502网关错误   503服务器超载或维护



GET和POST区别：GET：检索或获取内容     POST：创建/更新，用于表单提交之类的，有请求体

HTTP无状态，使用cookie，保持持久连接，但是有时间    HTTPS使用SSL/TSL进行加密

DNS域名解析，将域名变为ip地址

# 跨域的解决方案

1.  JSONP  客服端这边定义函数              服务器JSON(JS函数(真实数据))    最后客户端执行函数就行了
2. CORS  服务端设置响应头
3. Nginx   设置代理服务器

# cookie  storage   session   Token

cookie：客户端发请求，服务器响应同时设置Cookie，下次客户端发请求时将携带cookie,一开始是服务器发送给浏览器的，后面浏览器每次请求都会将cookie传给服务器

storage保存在本地

sessio （会话）为了解决cookie不安全引入的，session是保存在服务器的，包括了字符串和有效时间，将其通过cookie发给浏览器，这样浏览器就拿到了session（字符串）这样账号和密码就保存在了服务里或数据库里

Token  session会导致服务器压力大，因为保存了大量的session，所有引入token，服务器不需要保存，只要保存token签名的密文，浏览器将其token存储下来，当然token的安全性还是挺高的，包含三部分

# 创建对象方法

fetch也可以发送Ajax请求，基于promise，但是没有JSON转换，

1.  使用字面量
2. 使用原型   new Object()
3. Object.create()
4. 工厂模式   用构造函数取代，有一些缺点
5. 构造函数
6. class

# 防抖与节流

节流：在规定的时间只会触发一次，只有时间到了才会再次执行

# 正则表达式

``let d = /^1[34578]\d{9}$/``

``console.log(d.test(15901234567))``

方法：test()          exec()方法用于检索字符串中的正则表达式的匹配。如果字符串中有匹配的值返回该匹配值，否则返回 null。

字符串也有一些方法：search()返回第一个找到的索引，match()跟exec()差不多，可以返回一个或多个

| [[abc\]](https://www.runoob.com/jsref/jsref-regexp-charset.html) | 查找方括号之间的任何字符。         |
| ------------------------------------------------------------ | ---------------------------------- |
| [[^abc\]](https://www.runoob.com/jsref/jsref-regexp-charset-not.html) | 查找任何不在方括号之间的字符。     |
| [0-9]                                                        | 查找任何从 0 至 9 的数字。         |
| [a-z]                                                        | 查找任何从小写 a 到小写 z 的字符。 |
| [A-Z]                                                        | 查找任何从大写 A 到大写 Z 的字符。 |
| [A-z]                                                        | 查找任何从大写 A 到小写 z 的字符。 |
| [adgk]                                                       | 查找给定集合内的任何字符。         |
| [^adgk]                                                      | 查找给定集合外的任何字符。         |
| (red\|blue\|green)                                           | 查找任何指定的选项。               |

\s 空白字符  {}表示取多个，也可以表示数目范围{4,9}      ？表示可有可无   *表示0个或多个  +表示一个或多个

# promise核心代码

# 浅拷贝深拷贝，实现深拷贝方法

# 图片懒加载

# 事件冒泡与捕获

e.target     点击了哪个元素就返回哪个元素  

this   绑定了点击事件，那么就是他   其实就是ul  li  里面   this就是ul     e.target就是li

事件对象就是  event简写为e   在onclick或者监听的时候产生的

默认为冒泡，从下到上进行执行，

事件监听出现的冒泡，阻止冒泡  e.stopPropagation()//不考虑兼容性

如果同时出现冒泡与捕获，则先捕获，在执行目标也就是点的那个，在执行冒泡，（见桌面图）

# 事件委托

原理：给父节点添加侦听器，利用事件冒泡影响每一个节点   

就比如说ul  和  li   设置ul 监听   点击  li  然后就会通过事件冒泡触发ul点击事件  如果想获取li   就用e.target



排他思想：例如给一组button添加样式，可以for循环加绑定事件  然后再次for循环将全部颜色置为0，单独设置那个点击元素的颜色，用this

# new对象过程

1.创建一个对象

2.son.__proto__==Mother.prototype

3.新对象和函数调用的this进行绑定

4.执行构造函数代码

5.如果函数没有返回值，那么就会自动返回这个新对象（return this）

# 闭包

闭包定义：函数嵌套，内部函数使用了外部函数变量，调用外部函数

问题：闭包可能会引起内存泄漏，让某些值不会被释放，   但闭包让外部访问私有变量成为了可能，同时外部不能修改私有变量，只要return就行     将 f=null清除内存泄漏

生命周期：开始就不说了，1.闭包函数里面没有return直接调用外部函数，执行完之后被回收2.外部函数return内部函数，定义了一个变量如 let f = fn()  f()       执行完之后f仍然存在（全局变量），出现内存泄漏，此时闭包还在      用 f=null，释放闭包，也阻止了内存泄漏

闭包存在关键点：使用一个变量接受嵌套的内部函数，让它在执行完之后不会成为垃圾对象，闭包从而得以存在

内存泄漏与内存溢出  内存：暂时存放CPU中的运算数据

垃圾回收，定时清除闲置资源的一种机制  如标记清除法  标记内存中的所有变量

# 执行上下文和执行上下文栈

执行上下文：全局执行上下文，函数执行上下文，eval执行上下文（一般不用）其实就是变量提升，注意函数提升比变量提升优先，

**函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖**

​	a();  // 2
​     var a = function(){  // 看成是一个函数赋值给变量a
​        console.log(1)
​     }
​     a(); // 1
​     function a(){
​        console.log(2)
​     }
​     a(); // 1

执行上下文栈：将执行上下文压入栈中，调用函数就产生一个执行上下文，其实只需要理解函数的调用就行了，理解递归就行

